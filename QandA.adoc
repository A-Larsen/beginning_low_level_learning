== Working through Question 21
to find the number in each decimal place I could use the formula

----
 floor(mod(num / 10 ^place); 10)
----

but I also need to find the numbers width
for that I could use the formula

----
 round(log(10; num) + 1)
----

or

----
 count the number of times I can divide by 10 before reaching zero
----

make sure to use unsigned math to floor output maybe?
might try this without tail call optimization first

in this case I think I need to perform my own modulo
dang forgot an easy way to get remander from a division problem

math for creating modulo

----
 a / b = c
 round(c) * b = d
 a - d = answer
----

I can look through C's https://en.wikibooks.org/wiki/C_Programming/stdlib.h/itoa[itoa] source code and try something similar.

[source, c]
----
 void itoa(int n, char s[])
 {
     int i, sign;
 
     if ((sign = n) < 0)  /* record sign */
         n = -n;          /* make n positive */
     i = 0;
     do {       /* generate digits in reverse order */
         s[i++] = n % 10 + '0';   /* get next digit */
     } while ((n /= 10) > 0);     /* delete it */
     if (sign < 0)
         s[i++] = '-';
     s[i] = '\0';
     reverse(s);
 }
----


== Q and A


A19::
    r13 is not cleared before it is used and could return junk values

Q21::
    Try to rewrite `print_int` without calling `printf_uint` or copying its
    code: Hint read about tail call optimization

A21::
    look at question_print_int.nasm

Q33::
    What is a label and does it have a size?

A33::
    labels are address. The size is 8 bytes because pointers
