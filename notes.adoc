= Low Level learning

== Looking at the Intruction table
Ex.

.SAL/SHL
[cols="1,1,1,1,1,4"]
|===
|----------| Instruction      | Op/En | 64-bit Mode | Compat/Leg Mode | Description

| D0/4     | SAL r/m8, 1      | M1    | Valid       | valid           | Multiply r/m8 by 2, once

| C1 /4 ib | SHL r/m16,imm8   | M1    | Valid       | valid           | Multiply r/m32 by 2, once
|===


This is an example of an instruction table that you might see, In this case I took
this from the _Intel 64 and IA-32 Architectures software Developer's Manual_.
"r" stands for a general purpose register, "r/m8" mean a 8 bit register, "r/m16"
means a 16 bit register. "imm" stands for immediate value (e.g., integer
constant like 42 or 1335).

== What's the difference between the CF flag and OF flag.
Carry Flag::
    bits that are carried over in *UNSIGNED* integer arithmetic

Overflow Flag::
    bits that are carried over in *SIGNED* integer arithmetic

== What is that D Flag
The "D" flag determines the size of each element in the stack. It can be
changed, but changing it can result in an unaligned stack if you are not
careful.

== L vs H in registers
"L" is used as a mnemonic lower four bits of the last byte of a register. "H"
is used as a mnemonic as the upper for bits of the last byte of a register. Not
always the case, but sometimes holds true. For example, CL, is the last four
bits of the RCX register.

== Least significant vs Most significant
less significant bits are further the the right. More signifacant bits are
further to the right.

== What does the most significant bit mean in numbers?
It can either be a part of the bit of the number or thing it is trying to
represent if it is a unsigned number. Or it can represent whether a number is
"signed" or "unsigned" if it is a signed number.

== Data types
Quad Word:: 64 bits
Double Word:: 32 bits
Word:: 16 bits
Byte:: 8 bits

== lea vs mov
lea:: load effective address
mov:: load value

`lea` loads a pointer to the item you're addressing wheras `mov` loads the
actual value at that address.

== Getting the address of a "variable"
I put variable in quotes because there really isn't variables in assembly.

you can put brackets around a variable to get its address.

ex.

[source, nasm]
----
lea rsi, [variable]
----

square brackets represent *indirect addressing*.

== R_X vs E_X vs _X vs _H vs _L
R_X:: all 64 bits
E_X:: lower 32 bits
_X:: lower 16 bits
_H:: top 4 bits of last byte
_L:: bottom 4 bits of last byte

== How to get bits in the carry flag
?

== Main
One file in your assembly program needs "main" defined. This seems to be defined
in the `.text` section.

[source, nasm]
----
section .text
global main
main:
----

== Labels
- Labels look like this `<description>:`
- Local lablels Look like this `.<description>:`

If there is a local label within a global label then the full label name
could loop like this `main.loop`. Like in this example:

[source, nasm]
----
section .text
global main
main:
    .loop
    ; do somethings
    jnz .loop

----

== What is the differnce between SAR and SHR?
SAR sets or clears the most significant bit depending on the sign, While SHR
just clears the most significant bit.

== Jumping

`cmp` sets the approriate flags. `jl` jumps if rax < 42. `jmp` jumps straight to
the `ex` label.

[source, nasm]
----
    cmp rax, 42
    jl yes
    mov rbx, 0
    jmp ex
yes:
    mov rbx, 1
ex:
----

Other::
    1. `ja` (jump if above)/ `jb` (jump if below) for a jump after a comparison
       of _unsigned numbers with cmp_.

    2. `jg` (Jump if greater) / `jl` (jump if less) for _signed_.

    3. `jae` (jump if above or equal), jle (jump if less or equal) and similar

== Function Calls
`Instruction call <address>` is the same as:

[source, nasm]
----
push rip
jmp <address>
----

The address now stored in the stack (for rip contents) is called *return*
*address*.

the first six arguments are rdi, rsi, rdx, rcx, r8, and r9, respectively.

`ret` instruction denotes the function end. same as `pop rip`.

One should not invoke `ret` unless the stack is in exactly the same state as
when the function started.


Callee-saved registers::
    must be restored by the procedure being called.
    rbx, rbp, rsp, r12-r15

Caller-saved registers::
    Should be saved before invoking a function and restored after. All other
    registers are caller-saved.

pattern of calling a function:

- Save all caller-saved registers you want to survive function call (you can use
  push for that)

- Store arguments in the relevent register (rdi, rsi, etc).

- Invoke function returns, rax, will hold the return value.

- Restore caller-saved registers stored before the function call.


NOTE: some system calls also return values - be careful to read the docs!

== Syscalls
syscall instructions implicitly uses rcx. System calls cannot accept more than
six arguments.

All the syscalls are listed in _/usr/include/nasm/unistd.h_ (or something
similar), together with their numbers (the value to put in EAX before you call
int 80h). In ubuntu I found the file in
_/usr/include/x86_64-linux-gnu/asm/unistd_64.h_.


== Different Addressing types

=== Immediate
use the specified value

ex.

[source, nasm]
----
mov rax, 10
----

=== Register
Use the value in teh specified register

[source, nasm]
----
mov rax, rbx
----

[source, nasm]
----
mov rax, [10]; transfers 8 bytes starting at the tenth address into rax
----

[source, nasm]
----
mov r9, 10
mov rax, [r9] ; take the address from the register
----

=== Direct Memory
Use the value at the specified memory address

[source, nasm]
----
mov rdi, 0x172 ; not 100% sure about this
----

=== Base-indexed with scale and discplacement
Most addressing modes are generalized by this mode. The address here is
calculated based on the following components:

----
Address = base + index * scale + displacement
----

- Base is either immediate or a register
- Scale can only be immediate equal to 1, 2, 4, or 8
- Index is immediate or a register 
- Displacement is always immediate

[source, nasm]
----
mov rax, [rbx + 4 * rcx + 9]
mov rax, [4 * r9]
mov rdx, [rax + rbx]
lea rax, [rbx + rbx * 4] ; rax = rbx * 5
add r8, [9 + rbx * 8 + 7]
----

== ATT vs. Intel Syntax
gdb uses ATT syntax by default, but you can change it to intel (nasm's syntax)
with the command `set disassembly-flavor intel`


== Change a number from little endian to big endian in C

[source, c]
----
#include <stdio.h>
#include <stdlib.h>
#include <arpa/inet.h>

int
main(void){
    unsigned int num = 0x12345678;
    printf("%x\n", htonl(num));
}
----

== Strings
To explicitly state the length of a string:

[source, nasm]
----
db 27, 'Selling England by the Pound'
----

== Constant Precomputation
The math in the code belows is calculated at compile time and turned into a
constant

[source, nasm]
----
lab: db 0

mov rax, lab + 1 + 2 *3 
----

== Pointers and Differnt Addressing Types
Pointers are 8 bytes.

you need to specify operation size, when trying to write shomewhere a value
whose size is not specified.

[source, nasm]
----
section .data
    test: dq -1
section .bss
section .text
	global main
main:
   mov byte[test], 1 
    ;mov [test], 1 ; gives an error
   mov word[test], 1
   mov dword[test], 1
   mov qword[test], 1

	mov  rax, 60
	mov rdi, 0 
	syscall
----

== Two's complement
1. Do a logical not to all the bits
2. add 1

== Instructions
=== NEG
The `NEG` instruction applys two complement. It sets the CF falgs to zero if the
source operand is 0; otherwise it is set to 1.

=== IMUL
signed multiplication

One-operand form::
    secound operand is in AL, AX, EAX, or RAX, depending on the
    size

Two-operand form::
    With this form the destination operand (the first operand) is multiplied by
    the source operand

Three-operand form::
    with `mul a, b, c`, the multiplication of `b` and `c` is
    stored in `a`

=== MUL
unsigned multiply

the source operand is located in either AL, AX, or EAX, dending on the size of
the operand.

=== SUB
subtract source operand from the destination operand and stores the result in
the destination operand.

- integer subraction; signed and unsigned

- sets OF flags to indicate an overflow in the signed or unsigned result,
  respectively.

- The SF flag indicates the sign of the signed result

In 64-bit mode the instruction's default operation size is 32 bits

=== IDIV
signed divide. Divides the value in AX, DX:AX, or EDX:EAX (dividend) by the
source operand (divisor) and stores the result in AX (AH:AL), DX:AX, or EDX:EAX
registers.

- Overflow is indicated withthe #DE (divide error) exception rather than with
  the CF flag

=== DIV
Divids unsigned the value in the AX, DX:AX, EDX:EAX, or RDX:RAX registers
(dividend) by the source operand (divisor) and stores the result in AX (AH:AL),
DX:AX, EDX:EAX, or RDX:RAX register

example:

[source, nasm]
----
; Because the  dividend is RDX:RAX, we need to clear RDX and RAX
xor rdx, rdx
xor rax, rax

mov rax, 10 ; dividend (top)
mov rcx, 5 ; divisor (bottom)
div rcx  ; result is stored in RDX:RAX
mov rdi, rax ; returning the result as a exit number

mov rax, 60 ; exit syscall
syscall
----

== NASM and gdb
?

== Links
- https://www.felixcloutier.com/x86/[x86 and amd64 instruction reference]
- https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html[intel 64 IA-32 architectures Software Developer's Manual]
- https://redirect.cs.umbc.edu/portal/help/nasm/nasm.shtml[nasm and gdb]
- https://refspecs.linuxfoundation.org/elf/x86_64-abi-0.99.pdf[System V Application Binary Interface AMD64]
